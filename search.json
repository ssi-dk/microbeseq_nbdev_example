[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "microbeseq_nbdev_example",
    "section": "",
    "text": "This file will become your README and also the index of your documentation.",
    "crumbs": [
      "microbeseq_nbdev_example"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "microbeseq_nbdev_example",
    "section": "Install",
    "text": "Install\npip install microbeseq_nbdev_example",
    "crumbs": [
      "microbeseq_nbdev_example"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "microbeseq_nbdev_example",
    "section": "How to use",
    "text": "How to use\nFill me in please! Don’t forget code examples:\n\n1+1\n\n2",
    "crumbs": [
      "microbeseq_nbdev_example"
    ]
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Global static vars",
    "section": "",
    "text": "For help with the Markdown language, see this guide.",
    "crumbs": [
      "Global static vars"
    ]
  },
  {
    "objectID": "core.html#libraries",
    "href": "core.html#libraries",
    "title": "Global static vars",
    "section": "Libraries",
    "text": "Libraries\nCurrently all libraries included are listed at the top and calls to them are also made in the block of code that uses them. This is for readability and the performance hit of the import is negligible.",
    "crumbs": [
      "Global static vars"
    ]
  },
  {
    "objectID": "core.html#config",
    "href": "core.html#config",
    "title": "Global static vars",
    "section": "Config",
    "text": "Config\nOur config file holds all program and user specific variables. This is a good practice to follow as it allows us to easily change variables without having to change code. It also allows us to easily change variables based on the environment we are running in. For example, we may want to run a program in a test environment with a different database than we would in production. This is also a good practice to follow as it allows us to easily change variables without having to change code. It also allows us to easily change variables based on the environment we are running in. For example, we may want to run a program in a test environment with a different database than we would in production.\nConfiguration is templated to rely on environment (ENV) variables. A default ENV config is provided in ./config/config.default.env and more advanced data structures are supported in ./config/config.default.yaml. The .yaml file is meant to represent what your program actually works with and the .env file options the user can change at run time.\nMake sure you know the priority of variables and check on them when debugging your code. Also ensure that your yaml file is referenced appropriately in the .env file.\nWhen in use there’s an expectation you’ll have multiple config files for different use cases e.g. development, production environment for different paths, etc.\n\nset env variables\nA helper function for getting your config values, this will set the environment variables with the provided .env values. If you’re missing values it’ll ensure they’re loaded in with the defaults file.\n\nsource\n\n\nset_env_variables\n\n set_env_variables (config_path:str, overide_env_vars:bool=True)\n\n\n\nget config\nWhen you run this function, assuming things are set up properly, you end up with a dict that matches your .yaml file. This file will have all the inputs for the package and settings of your program.\nTo do this it will use a .env config file, which has an associated yaml file defined with CORE_YAML_CONFIG_FILE in the .env file. And then use the .env file to load values into the associated .yaml file.\n\nsource\n\n\nget_config\n\n get_config (config_path:str=None, overide_env_vars:bool=True)\n\n\n\nVariables\nAll the user input variables and machine adjustable variables should be in your config, which is a dict. Reference config.default.yaml for how to access your variables. Also note that with python dicts you can use dict_variable.get(\"variable\", default_value) to ensure that you don’t get a key error if the variable is not set.\n\n\nshow project env vars\nA helper function intended to only be used with debugging. It shows all your project specific environmental variables.\n\nsource\n\n\nshow_project_env_vars\n\n show_project_env_vars (config:dict)",
    "crumbs": [
      "Global static vars"
    ]
  },
  {
    "objectID": "core.html#get_samplesheet",
    "href": "core.html#get_samplesheet",
    "title": "Global static vars",
    "section": "get_samplesheet",
    "text": "get_samplesheet\nThis function is to unify the way we work with sample_sheet’s which is for us a file with a table of values, typically samples for batch processing. We want to approach doing it this way so all programs have batch processing in mind and working with the same data structure.\nTo make use of it we have a small sample_sheet yaml object which looks like\nsample_sheet:\n    path: path/to/sample_sheet.tsv\n    delimiter: '\\t' # Optional, will assume , for csv and \\t otherwises\n    header: 0 # Optional, 0 indicates first row is header, None indicates no header\n    columns: ['column1', 'column2', 'column3'] # Optional, if not provided all columns will be used\nMake sure to add that to your relevant section in your config (can be multiple times if you’re working with different sheets or different columns), then call the function on this object and it’ll either mention somethings wrong or return a pandas dataframe with the columns of interest.\nThis is an example of a common sample_sheet we work with. We will ingest the hash at the beginning so it doesn’t affect column naming. Extra empty rows at the end are also stripped.\n#sample_id  file_path   metadata1   metadata2\nSample1 /path/to/sample1.fasta  value1  option1\nSample2 /path/to/sample2.fasta  value2  option2\nSample3 /path/to/sample3.fasta  value3  option1\nSample4 /path/to/sample4.fasta  value1  option2\nSample5 /path/to/sample5.fasta  value2  option1\n\nsource\n\nget_samplesheet\n\n get_samplesheet (sample_sheet_config:dict)\n\nThe functions below are not tempalted and you should adjust this with your own code. It’s included as an example of how to code some functions with associated tests and how to make it work on the command line. It is best to code by creating a new workbook and then importing the functions of this into that one.\n\nsource\n\n\nhello_world\n\n hello_world (name:str='Not given')\n\nThis here is a a test as part of fastcore.test, all fastcore tests will be automatically run when doing nbdev_test as well as through github actions.\n\ntest.test_eq(\"Hello World! My name is Kim\", hello_world(\"Kim\"))\n\nThe @call_parse will, with the settings.ini entry way, automatically transform your function into a command line tool. Comments of the functions will appear for help messages and the initial docstring will appear in the help as well. You can also define defaults for the arguments and should define a typehint to control inputs. The function will likely have to resolve variables with ENV vars and config files. The recommended way to do this is to assume variables passed here are a higher priority.\n\nsource\n\n\ncli\n\n cli (name:str, config_file:str=None)\n\nThis will print Hello World! with your name\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr\n\nYour name\n\n\nconfig_file\nstr\nNone\nconfig file to set env vars from\n\n\n\nTest the function with potentially variable input to confirm output\n\ntest.test_eq(\n    \"Hello World! My name is Kim\", hello_world(config[\"example\"][\"input\"][\"name\"])\n)\ntest.test_eq(None, cli(\"Kim\"))\n\n\ncli(config[\"example\"][\"input\"][\"name\"])\ncli(config[\"example\"][\"input\"][\"alternative_name\"])",
    "crumbs": [
      "Global static vars"
    ]
  },
  {
    "objectID": "hello_world.html",
    "href": "hello_world.html",
    "title": "Additional Learning Resources",
    "section": "",
    "text": "Now that you’ve finished the getting started in ./GETTING_STARTED_WITH_TEMPLATE.md, you’ll notice the directory has many new files and folders. In this example $YOUR_REPO_NAME is template_nbdev_example so be sure to adjust accordingly.\nThere’s now\n./_docs\n.quarto\n./template_nbdev_example # This is the code autogenerated from the notebooks, you should only adjust this through your notebooks\n./template_nbdev_example/__pycache__\n./template_nbdev_example/__init__.py\n./template_nbdev_example/_modidx.py\n./template_nbdev_example/core.py\n./template_nbdev_example/hello_world.py\n./template_nbdev_example.egg-info # This is metadata about the package for pip\n_quarto.yml\nindex.ipynb # This is a notebook for showing how the program works and generated the README.md, you should adjust this\nMANIFEST.in # This determines what files outside of .py files are included in the package, you may need to adjust it.\nREADME.md\nsetup.py # This is the file that tells pip how to install the package, you shouldn't need to edit this ever\nstyles.css\n\nIf you want to check what you’re documentation looks like run nbdev_preview in command line of the project folder\n\n\nLibraries\nHere we include all the libraries of this module. You can see they’re sectioned so the top parts can be easy cut and paste into new files.\nNormally your imports go into Project specific libraries above, but we’ll put it in a code block here. In this example you’ll want to comment out the code below, because YOUR_REPO_NAME changes with each repository, it’ll cause issues if you try to run it with a different repository name\nNow you have access to your functions in core.py and call call them here.\nNOTE: if you change another notebook, run nbdev_prepare, and restart your current kernel to see the changes\nHere’s we’ll load the config file values, note that the file isn’t exported so is for development and documentation purposes.\n\nconfig = core.get_config()  # This will load the .env file and print the config\n\nLets look at our values, as we have a dictionary, that can be viewed more nicely as a json object\n\n# print the config as a json string\nprint(json.dumps(config, indent=4))\n\nLets make our own hello_world that’s a bit different from the test in core. It take’s two names! This is exported so it goes into our module, meaning it can be refernced with template_nbdev_example.hello_world\n\nsource\n\nhello_two_world\n\n hello_two_world (name1:str, name2:str)\n\nNow lets also make a function thats intended to call from the command line. As we intend that make sure you get your config variables and handle them properly!\n\nsource\n\n\ncli\n\n cli (name:str=None, alternative_name:str=None, config_file:str=None)\n\nThis will print Hello World! with your name\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr\nNone\nA name\n\n\nalternative_name\nstr\nNone\nAn alternative name\n\n\nconfig_file\nstr\nNone\nconfig file to set env vars from\n\n\nReturns\nNone\n\n\n\n\n\nSo now that it exists lets add it to our settings.ini, the console_scripts section, once edited by you should look like\nconsole_scripts =\n    core_hello_world=template_nbdev_example.core:hello_world\n    hello_two_world=template_nbdev_example.hello_world:cli\nnow you’ll need to run nbdev_prepare to turn this into a module and gain access to your new commands, if your commands aren’t showing up ensure you’ve run python -m pip install -e '.[dev]' in your ./venv\nThe ! lets you run on the command line, so the following block only works if everything above is successful. Remember to restart your kernel if you make changes to the module.\n\n!hello_two_world\n\nWith some different values\n\n!hello_two_world --name \"John\" --alternative_name \"Jane\"\n\nTry using an alternative config as well\n\n!hello_two_world --config_file \"./config.default.env\"\n\nNice, you can also run these through the notebook as a function\n\ncli(name=\"John\", alternative_name=\"Jane\", config_file=\"./config.default.env\")\n\nLets add a test here as well, which will get run through ./.github/workflows/test.yaml whenever changes happen to the repository\n\ntest.test_eq(\n    None,\n    cli(name=\"John\", alternative_name=\"Jane\", config_file=\"./config.default.env\"),\n)\n\nIf you’re on the default config.default.env and config.default.yaml you’ll see at the bottom: “example.input.name”: “Kim”, “example.input.alternative_name”: “Lee” I encourage you to adjust these values to get familiar with the config files\nThat’s the demo for now, feel free to create issues if you have suggestions to add.",
    "crumbs": [
      "Additional Learning Resources"
    ]
  }
]