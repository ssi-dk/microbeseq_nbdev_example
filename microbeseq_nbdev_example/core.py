# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['PACKAGE_NAME', 'DEV_MODE', 'PACKAGE_DIR', 'PROJECT_DIR', 'config', 'set_env_variables', 'get_config',
           'show_project_env_vars', 'hello_world', 'cli']

# %% ../nbs/00_core.ipynb 4
# Need the microbeseq_nbdev_example for a few functions, this can be considered a static var
PACKAGE_NAME: str = (
    "microbeseq_nbdev_example"  # Make sure to adjust this to your package name
)
DEV_MODE: bool = (
    False  # set below to override, as this is in an export block it'll be exported while the dev mode section is not
)
PACKAGE_DIR = None  # set in dev mode
PROJECT_DIR = None  # set in dev mode

# %% ../nbs/00_core.ipynb 10
# standard libs
import os
import re

# Common to template
# add into settings.ini, requirements, package name is python-dotenv, for conda build ensure `conda config --add channels conda-forge`
import dotenv  # for loading config from .env files, https://pypi.org/project/python-dotenv/
import envyaml  # Allows to loads env vars into a yaml file, https://github.com/thesimj/envyaml
import fastcore  # To add functionality related to nbdev development, https://github.com/fastai/fastcore/
from fastcore import (
    test,
)
from fastcore.script import (
    call_parse,
)  # for @call_parse, https://fastcore.fast.ai/script

# Project specific libraries

# %% ../nbs/00_core.ipynb 13
import importlib
import importlib.util


def set_env_variables(config_path: str, overide_env_vars: bool = True) -> bool:
    # Load dot env sets environmental values from a file, if the value already exists it will not be overwritten unless override is set to True.
    # If we have multiple .env files then we need to apply the one which we want to take precedence last with overide.

    # Order of precedence: .env file > environment variables > default values
    # When developing, making a change to the config will not be reflected until the environment is restarted

    # Set the env vars first, this is needed for the card.yaml to replace ENV variables
    # NOTE: You need to adjust PROJECT_NAME to your package name for this to work, the exception is only for dev purposes
    # This here checks if your package is installed, such as through pypi or through pip install -e  [.dev] for development. If it is then it'll go there and use the config files there as your default values.
    spec = importlib.util.find_spec(PACKAGE_NAME)
    if (
        DEV_MODE
    ):  # Means we are in development and can reference the package path directly as it's relative to this code.
        try:
            dotenv.load_dotenv(
                f"{PACKAGE_DIR}/config/config.default.env", override=False
            )
        except Exception as e:
            print(f"Error: {PACKAGE_DIR}/config/config.default.env does not exist")
            return False
    elif (
        spec is not None
    ):  # Means the package is installed and we should get defaults from the package
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(
            module
        )  # load the module which means we know where the package is with module.__path__[0]
        try:
            dotenv.load_dotenv(
                f"{module.__path__[0]}/config/config.default.env", override=False
            )
        except Exception as e:
            print(
                f"Error: {module.__path__[0]}/config/config.default.env does not exist"
            )
            return False
    # 2. set values from file:
    if os.path.isfile(config_path):
        dotenv.load_dotenv(config_path, override=overide_env_vars)

    return True

# %% ../nbs/00_core.ipynb 15
import importlib
import importlib.util


def get_config(config_path: str = None, overide_env_vars: bool = True) -> dict:
    if config_path is None:
        config_path = ""
    # First sets environment with variables from config_path, then uses those variables to fill in appropriate values in the config.yaml file, the yaml file is then returned as a dict
    # If you want user env variables to take precedence over the config.yaml file then set overide_env_vars to False
    set_env_variables(config_path, overide_env_vars)
    if (
        DEV_MODE
    ):  # Means we are in development and can reference the package path directly as it's relative to this code.
        config: dict = envyaml.EnvYAML(
            os.environ.get(
                "CORE_YAML_CONFIG_FILE", f"{PACKAGE_DIR}/config/config.default.yaml"
            ),
            strict=False,
        ).export()
    else:
        spec = importlib.util.find_spec(PACKAGE_NAME)
        if spec is not None:
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            config: dict = envyaml.EnvYAML(
                os.environ.get(
                    "CORE_YAML_CONFIG_FILE",
                    f"{module.__path__[0]}/config/config.default.yaml",
                ),
                strict=False,
            ).export()

    return config

# %% ../nbs/00_core.ipynb 17
# create a os.PathLike object
config = get_config(os.environ.get("CORE_CONFIG_FILE", ""))

# %% ../nbs/00_core.ipynb 19
def show_project_env_vars(config: dict) -> None:
    # Prints out all the project environment variables
    # This is useful for debugging and seeing what is being set
    for k, v in config.items():
        # If ENV var starts with PROJECTNAME_ then print
        if k.startswith(config["CORE_PROJECT_VARIABLE_PREFIX"]):
            print(f"{k}={v}")

# %% ../nbs/00_core.ipynb 22
def hello_world(name: str = "Not given") -> str:
    return f"Hello World! My name is {name}"

# %% ../nbs/00_core.ipynb 26
from fastcore.script import call_parse


@call_parse
def cli(
    name: str,  # Your name
    config_file: str = None,  # config file to set env vars from
):
    """
    This will print Hello World! with your name
    """
    config = get_config(config_file)  # Set env vars and get config variables
    if name is not None:
        config["example"]["user_input"]["name"] = name

    print(hello_world(config["example"]["user_input"]["name"]))
